# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fCsiCdXPqdXWcFrqDckzQBUaX-C9HKsN
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from geopy.distance import geodesic
from sklearn.cluster import KMeans
import random
import folium
from streamlit_folium import st_folium

st.title("TSP AI Route Optimizer")

# File upload
uploaded_file = st.file_uploader("Upload your CSV file", type="csv")
if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)
    st.write("Preview of uploaded data:", df.head())

    # Input: number of drivers
    num_driver = st.number_input("Number of drivers", min_value=1, step=1, value=1)

    # Input: depot location
    depot_lat = st.number_input("Depot latitude", format="%.6f")
    depot_lon = st.number_input("Depot longitude", format="%.6f")

    # Check required columns
    id_cols = ['Delivery_location_latitude', 'Delivery_location_longitude']
    if not all(col in df.columns for col in id_cols):
        st.error(f"Missing columns: {', '.join([col for col in id_cols if col not in df.columns])}")
        st.stop()

    # Assign ID
    df['id'] = df[id_cols].ne(df[id_cols].shift()).any(axis=1).cumsum()
    first_column = df.pop('id')
    df.insert(0, 'id', first_column)

    # Calculate distance from depot
    df['Distance (km)'] = df.apply(
        lambda row: geodesic(
            (row['Delivery_location_latitude'], row['Delivery_location_longitude']),
            (depot_lat, depot_lon)
        ).kilometers, axis=1
    )

    # KMeans clustering
    coords = df[['Delivery_location_latitude', 'Delivery_location_longitude']].values
    kmeans = KMeans(n_clusters=num_driver, random_state=42)
    df['Cluster'] = kmeans.fit_predict(coords)

    # TSP functions
    def distance_matrix(location):
        return [
            [geodesic(location[i], location[j]).kilometers for j in range(len(location))]
            for i in range(len(location))
        ]

    def total_distance(route, dist_matrix):
        return sum(dist_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) + dist_matrix[route[-1]][route[0]]

    def simulated_annealing_tsp(dist_matrix, initial_temp=10000, cooling_rate=0.995, stopping_temp=1e-8, max_iter=1000):
        n = len(dist_matrix)
        current_route = list(range(n))
        current_distance = total_distance(current_route, dist_matrix)
        best_route = list(current_route)
        best_distance = current_distance
        temp = initial_temp

        while temp > stopping_temp:
            for _ in range(max_iter):
                i, j = random.sample(range(1, n), 2)
                new_route = list(current_route)
                new_route[i], new_route[j] = new_route[j], new_route[i]
                new_distance = total_distance(new_route, dist_matrix)
                if new_distance < current_distance or random.random() < np.exp((current_distance - new_distance) / temp):
                    current_route = new_route
                    current_distance = new_distance
                    if new_distance < best_distance:
                        best_route = new_route
                        best_distance = new_distance
            temp *= cooling_rate
        return best_route, best_distance

    # Plotting and Folium map
    colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']
    m = folium.Map(location=[df['Delivery_location_latitude'].mean(), df['Delivery_location_longitude'].mean()], zoom_start=5)

    for driver_id in range(num_driver):
        driver_group = df[df['Cluster'] == driver_id]
        total_locations = list(zip(driver_group['Delivery_location_latitude'], driver_group['Delivery_location_longitude']))
        location = [(depot_lat, depot_lon)] + total_locations

        best_route, min_cost = simulated_annealing_tsp(distance_matrix(location))

        # Matplotlib plot
        route_lats = [location[i][0] for i in best_route] + [location[best_route[0]][0]]
        route_lons = [location[i][1] for i in best_route] + [location[best_route[0]][1]]

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(driver_group['Delivery_location_longitude'], driver_group['Delivery_location_latitude'], c='b')
        ax.scatter(depot_lon, depot_lat, color='orange', marker='x', s=100, label='Depot')
        ax.plot(route_lons, route_lats, color='blue', linewidth=2, label='Route')
        for order, i in enumerate(best_route):
            ax.text(location[i][1], location[i][0], str(order), fontsize=12, ha='left', va='bottom', color='red')
        ax.set_title(f"Delivery Route for Driver {driver_id}")
        ax.set_xlabel('Longitude')
        ax.set_ylabel('Latitude')
        ax.legend()
        st.pyplot(fig)

        # Folium route
        route_coords = [location[i] for i in best_route] + [location[best_route[0]]]
        folium.PolyLine(route_coords, color=colors[driver_id % len(colors)], weight=4, opacity=0.8).add_to(m)
        for order, (lat, lon) in enumerate(route_coords):
            folium.Marker([lat, lon], popup=f'Stop {order}', icon=folium.Icon(color=colors[driver_id % len(colors)])).add_to(m)

    st.subheader("Interactive Map")
    st_folium(m, width=700, height=500)